# GAIA-WorkSpace-Phone 技术架构与开发指导文档

## 一、产品概述

### 1.1 产品定位

**GAIA-WorkSpace-Phone** 是一款运行在 PC/Mac 上的桌面软件，通过 ADB 连接安卓手机，利用多模态大模型作为"大脑"，通过视觉识别手机屏幕，自动规划任务路径，并模拟人类手指操作，实现"一句话操控手机"的智能体验。

**核心理念**："See, Think, Act" (看见，思考，行动)

### 1.2 目标用户

- 极客与开发者：App 自动化测试、批量操作手机
- 新媒体/电商运营：跨 App 操作、数据采集、私信回复
- 办公白领：在电脑上无缝处理手机事务
- 无障碍需求者：通过语音或键盘指令操作手机

---

## 二、主要功能模块

### 2.1 智能投屏与连接 (The Link)

- **ADB 连接**：支持 USB 有线（低延迟）和 Wi-Fi 无线连接
- **高清投屏**：基于 Scrcpy 核心技术，实时显示手机画面（低至 30ms 延迟）
- **键鼠映射**：允许用户在 AI 不工作时，使用鼠标和键盘直接操作手机

### 2.2 自然语言任务规划 (The Brain)

- **意图理解**：用户在侧边栏输入自然语言指令
- **任务拆解 (Chain of Thought)**：将复杂任务拆解为多个步骤
- **动态规划**：识别异常（如弹窗、广告）并自动处理，重新回到主任务线

### 2.3 视觉感知与动作执行 (The Hands & Eyes)

- **UI 元素检测**：利用 GUI-Grounding 模型，精准识别屏幕上的图标、按钮、文本框的坐标
- **拟人化操作**：支持丰富的操作类型（参考 Open-AutoGLM 项目）：
  - **基础触摸**：点击、双击、长按、滑动
  - **文本输入**：输入文本、清除文本、键盘管理
  - **系统按键**：返回、主页、启动应用
  - **辅助操作**：等待、截图、获取当前应用
  - **特殊操作**：用户接管、内容记录、API 调用
- **操作回显**：在桌面端投屏画面上，实时绘制 AI 的"注视点"（高亮框）和"点击点"

### 2.4 工作流记忆 (Workspace Memory)

- **技能学习**：用户可以演示一遍操作，AI 记录路径并泛化为通用脚本
- **常用指令库**：保存常用的 Prompt，一键触发

---

## 三、技术架构设计

### 3.1 核心架构模式：Sidecar 模式 (边车模式)

采用 **Electron (UI) + Python (Service)** 分离架构，避免在 Node.js 中直接调用 Python 脚本导致的性能问题。

#### 架构层次

```
┌─────────────────────────────────────────────────┐
│         Electron 渲染进程 (Frontend)            │
│         Vue.js UI 界面                          │
│         WebCodecs 视频解码                      │
└──────────────┬──────────────────────────────────┘
               │ HTTP/WebSocket (localhost)
               │
┌──────────────▼──────────────────────────────────┐
│      Electron 主进程 (Node.js)                  │
│      - 应用生命周期管理                          │
│      - 窗口管理、原生菜单、系统托盘              │
│      - Python 进程启动与守护                     │
└──────────────┬──────────────────────────────────┘
               │ 进程管理
               │
┌──────────────▼──────────────────────────────────┐
│      Python 后端服务 (独立进程)                 │
│      - FastAPI HTTP/WebSocket 服务器            │
│      - ADB 通信管理 (adbutils)                  │
│      - Scrcpy 视频流转发                         │
│      - AI 视觉识别与任务规划                     │
│      - 图像处理算法                              │
└──────────────┬──────────────────────────────────┘
               │ ADB/Socket
               │
┌──────────────▼──────────────────────────────────┐
│            Android 设备                          │
│            - Scrcpy Server                       │
│            - ADB Daemon                          │
└─────────────────────────────────────────────────┘
```

#### 关键设计原则

1. **进程隔离**：Python 后端作为独立服务运行，通过 HTTP/WebSocket 与前端通信
2. **直接通信**：渲染进程直接与 Python 服务通信，绕过主进程以减少 IPC 开销
3. **异步处理**：Python 侧使用 asyncio 保证视频流传输不阻塞控制指令
4. **资源隔离**：使用内置 ADB 二进制，避免与系统环境变量冲突

### 3.2 技术选型

| 层级            | 技术                                 | 说明                         |
| --------------- | ------------------------------------ | ---------------------------- |
| **前端框架**    | Vue.js                               | UI 界面开发                  |
| **桌面框架**    | Electron                             | 跨平台桌面应用               |
| **构建工具**    | Electron-Vite                        | 快速构建与热更新             |
| **后端框架**    | FastAPI                              | Python HTTP/WebSocket 服务器 |
| **Python 打包** | PyInstaller                          | 单文件模式打包为 .exe/.mac   |
| **视频解码**    | WebCodecs API (首选) / JMuxer (备选) | 前端视频流解码               |
| **ADB 管理**    | adbutils                             | Python ADB 操作库            |
| **异步框架**    | asyncio                              | Python 异步处理              |

### 3.3 通信协议设计

#### 视频流传输

- **协议**：WebSocket
- **流程**：Python 后端通过 Socket 读取 Scrcpy 裸流 → WebSocket → 前端 WebCodecs/JMuxer 解码
- **优化**：动态比特率、丢帧策略、5GHz Wi-Fi 检测

#### 控制指令传输

- **协议**：HTTP RESTful API
- **流程**：前端 → HTTP 请求 → Python FastAPI → ADB/Scrcpy 控制 Socket
- **操作类型**：支持丰富的操作指令（参考 4.3.3 动作执行部分）：
  - 基础触摸：Tap、Double Tap、Long Press、Swipe
  - 文本输入：Type、Clear Text、键盘管理
  - 系统按键：Back、Home、Launch App
  - 辅助操作：Wait、Get Screenshot、Get Current App
  - 特殊操作：Take_over、Note、Call_API、Interact、Finish

#### 状态同步

- **协议**：WebSocket (双向)
- **内容**：设备连接状态、任务执行进度、AI 思考过程、错误信息

---

## 四、核心模块详细设计

### 4.1 ADB 连接管理模块

#### 4.1.1 连接模式

ADB 支持两种连接方式：**USB 有线连接**和**Wi-Fi 无线连接**。两种方式各有优势，软件应同时支持并允许用户切换。

##### USB 有线连接（推荐用于关键任务）

**优势**：

- **低延迟**：物理连接，延迟通常 < 10ms，远低于无线连接
- **高稳定性**：不受网络波动影响，连接稳定可靠
- **高带宽**：USB 2.0/3.0 提供充足带宽，视频流更流畅
- **无需配置**：插入即用，无需 Wi-Fi 或配对码
- **适合场景**：支付操作、抢票、自动化测试等对延迟和稳定性要求高的任务

**连接流程**：

```
1. USB 插入检测
   - 监听 USB 设备插拔事件（Windows: WMI, macOS: IOKit）
   - 或定时轮询 `adb devices` 检测新设备

2. 驱动检测与安装
   - Windows: 检测是否安装 USB 驱动（Google USB Driver）
   - macOS/Linux: 通常无需额外驱动
   - 如未安装，提示用户安装或提供驱动下载链接

3. USB 授权处理
   - 首次连接时，手机会弹出"允许 USB 调试"授权弹窗
   - 软件检测到设备状态为 "unauthorized"
   - UI 提示用户："请在手机上点击'允许 USB 调试'"
   - 可选：支持"始终允许此计算机"复选框，避免重复授权

4. 设备识别
   - 执行 `adb devices` 获取设备列表
   - 解析设备序列号、状态（device/offline/unauthorized）
   - 获取设备信息：`adb -s <serial> shell getprop ro.product.model`

5. 连接建立
   - 设备状态为 "device" 时，连接成功
   - 启动 Scrcpy Server：`adb -s <serial> push scrcpy-server.jar /data/local/tmp/`
   - 建立视频流和控制通道

6. 连接保持
   - 持续监控设备状态
   - 检测到 "offline" 或设备消失时，触发重连或提示用户
```

**USB 授权处理细节**：

- **检测授权状态**：

  ```python
  # adb devices 输出示例
  # List of devices attached
  # ABC123XYZ    device          # 已授权
  # DEF456UVW    unauthorized    # 未授权
  # GHI789RST    offline         # 离线
  ```

- **授权超时处理**：

  - 检测到 "unauthorized" 状态超过 30 秒
  - 提示用户检查手机屏幕，重新插拔 USB 线
  - 提供"重新检测"按钮

- **多设备支持**：
  - 同时连接多台设备时，显示设备列表供用户选择
  - 使用 `-s <serial>` 指定设备进行操作

##### Wi-Fi 无线连接（推荐用于日常使用）

**模式一：传统 TCP/IP 模式（Android 10 及以下，或通用场景）**

**特点**：首次连接通常需要 USB 线辅助开启端口，之后可拔线使用无线连接。

**连接流程**：

```
1. USB 插入 → 检测设备 (adb devices)
2. 切换模式 → adb tcpip 5555
3. 获取 IP → adb shell ip route / ifconfig
4. 建立连接 → adb connect <IP>:5555
5. 拔线提示 → 切换为无线模式
```

**模式二：Android 11+ 原生无线调试**

**特点**：无需 USB 线即可完成配对，但流程稍复杂。

**连接流程**：

```
1. 服务发现 → mDNS 扫描 (_adb-tls-connect._tcp)
2. 用户输入 → IP、端口、6位配对码
3. 配对 → adb pair <IP>:<Port> <PairingCode>
4. 连接 → adb connect <IP>:<ConnectPort>
```

**USB vs Wi-Fi 连接对比**：

| 维度           | USB 有线连接         | Wi-Fi 无线连接            |
| -------------- | -------------------- | ------------------------- |
| **延迟**       | < 10ms（极低）       | 20-100ms（受网络影响）    |
| **稳定性**     | 极高（物理连接）     | 中等（受网络波动影响）    |
| **带宽**       | 高（USB 2.0/3.0）    | 中等（受 Wi-Fi 质量影响） |
| **便利性**     | 需要插线             | 无需线缆，更自由          |
| **适用场景**   | 关键任务、低延迟需求 | 日常使用、移动场景        |
| **配置复杂度** | 低（插入即用）       | 中等（需要 Wi-Fi 和配对） |

#### 4.1.2 稳定性优化

##### USB 有线连接优化

**USB 插拔检测**

- **实时监听**：
  - Windows: 使用 WMI (Windows Management Instrumentation) 监听 USB 设备插拔事件
  - macOS: 使用 IOKit 框架监听 USB 设备变化
  - Linux: 监听 `/dev/bus/usb` 目录变化或使用 udev
- **自动重连**：检测到设备重新插入时，自动恢复连接和视频流
- **状态提示**：设备拔出时，UI 显示"设备已断开"，等待重新连接

**驱动检测与提示**

- **自动检测**：启动时检测系统是否已安装 USB 驱动
- **友好提示**：未检测到驱动时，提供清晰的安装指引和下载链接
- **驱动安装验证**：安装后自动验证，避免用户困惑

**USB 授权处理优化**

- **授权状态监控**：持续监控设备授权状态（device/unauthorized/offline）
- **超时提示**：检测到 "unauthorized" 超过 30 秒，提示用户检查手机
- **一键重试**：提供"重新检测授权"按钮，方便用户操作
- **授权记忆**：记录已授权设备，下次连接时快速识别

**多设备管理**

- **设备列表**：同时连接多台设备时，显示设备列表（序列号、型号、状态）
- **设备选择**：用户可选择当前操作的设备
- **设备切换**：支持快速切换设备，无需重新连接

##### Wi-Fi 无线连接优化

**心跳保活机制**

- 后台守护线程，每 2-5 秒发送轻量级指令检测连接
- 连续 2 次超时判定为断连
- 自动重连：指数退避策略 (1s, 3s, 5s, 10s)

**视频流传输优化**

- 强制 5GHz Wi-Fi 检查（2.4GHz 干扰大）
- 动态比特率：根据网络延迟调整 (8Mbps/1080p → 4Mbps/720p)
- 丢帧策略：AI 识别 30fps 足够，降低带宽占用

**IP 地址变动处理**

- 记录设备 MAC 地址与 IP 对应关系
- IP 失效时快速扫描局域网寻找新 IP

##### 通用优化策略

**ADB Server 管理**

- 使用私有 ADB 实例（内置二进制，避免冲突）
- 自定义端口：`ADB_SERVER_SOCKET=tcp:5038`
- 进程守护：检测到崩溃立即重启并恢复连接

**连接质量监控**

- **延迟检测**：定期测量 ADB 命令响应时间
- **带宽检测**：监控视频流传输速率
- **质量指示器**：UI 显示连接质量（优秀/良好/一般/差）
- **自动降级**：连接质量差时，自动降低视频流质量或提示切换到 USB

**错误恢复机制**

- **连接失败重试**：自动重试 3 次，失败后提示用户
- **一键修复**：提供"修复连接"按钮，执行 `adb kill-server` → `adb start-server` → 重新连接
- **错误日志**：记录详细错误信息，便于问题排查

### 4.2 视频流处理模块

#### 4.2.1 Scrcpy 集成

- Python 后端启动 Scrcpy Server（推送 jar 到手机）
- 通过 Socket 接收 H.264 视频流
- 转发到前端 WebSocket

#### 4.2.2 前端解码

- **首选**：WebCodecs API（性能最优）
- **备选**：JMuxer（稳定性高，性能略低）

#### 4.2.3 性能优化

- 图像解码不在 Python 端处理，只做转发
- AI 识别另开线程，不阻塞视频流转发循环

### 4.3 AI 核心模块

#### 4.3.1 视觉感知

- **输入**：截取视频流帧
- **模型选择**：
  - 云端：OpenAI GPT-4o（读图和坐标输出能力强）
  - 本地：MiniCPM-V 或 Qwen-VL（隐私敏感用户）
- **输出**：UI 元素坐标、类型、可操作性

#### 4.3.2 任务规划

- **框架**：ReAct (Reasoning and Acting)
- **流程**：观察 → 思考 → 动作 → 观察（循环）
- **能力**：
  - 意图理解
  - 任务拆解 (Chain of Thought)
  - 异常处理（弹窗、广告识别与关闭）

#### 4.3.3 动作执行

**参考项目**：本项目的操作类型参考了 Open-AutoGLM 项目的实现（位于 `lib/Open-AutoGLM/`），该开源项目提供了完整的 Android 设备操作能力。

**基础触摸操作**：

| 操作类型       | 说明     | ADB 实现                                        | 参数                          |
| -------------- | -------- | ----------------------------------------------- | ----------------------------- |
| **Tap**        | 单次点击 | `input tap <x> <y>`                             | 坐标 (x, y)                   |
| **Double Tap** | 双击     | 连续两次 `input tap`                            | 坐标 (x, y)                   |
| **Long Press** | 长按     | `input swipe <x> <y> <x> <y> <duration_ms>`     | 坐标、持续时间（默认 3000ms） |
| **Swipe**      | 滑动     | `input swipe <x1> <y1> <x2> <y2> <duration_ms>` | 起始坐标、结束坐标、持续时间  |

**文本输入操作**：

| 操作类型                        | 说明                  | 实现方式                                  | 备注                  |
| ------------------------------- | --------------------- | ----------------------------------------- | --------------------- |
| **Type / Type_Name**            | 输入文本              | ADB Keyboard 广播 `ADB_INPUT_B64`         | 需要安装 ADB Keyboard |
| **Clear Text**                  | 清除输入框文本        | ADB Keyboard 广播 `ADB_CLEAR_TEXT`        | 清除当前焦点输入框    |
| **Detect and Set ADB Keyboard** | 检测并切换到 ADB 键盘 | `ime set com.android.adbkeyboard/.AdbIME` | 自动检测并切换        |
| **Restore Keyboard**            | 恢复原始键盘          | `ime set <original_ime>`                  | 输入完成后恢复        |

**系统按键操作**：

| 操作类型   | 说明     | ADB 实现                                                    | 用途             |
| ---------- | -------- | ----------------------------------------------------------- | ---------------- |
| **Back**   | 返回键   | `input keyevent 4`                                          | 返回上一页       |
| **Home**   | 主页键   | `input keyevent KEYCODE_HOME`                               | 返回桌面         |
| **Launch** | 启动应用 | `monkey -p <package> -c android.intent.category.LAUNCHER 1` | 通过包名启动应用 |

**辅助操作**：

| 操作类型            | 说明         | 实现方式                     | 用途                     |
| ------------------- | ------------ | ---------------------------- | ------------------------ |
| **Wait**            | 等待         | `time.sleep(duration)`       | 等待界面响应，默认 1 秒  |
| **Get Current App** | 获取当前应用 | `dumpsys window` 解析        | 识别当前运行的应用       |
| **Get Screenshot**  | 截图         | `screencap` 或 Scrcpy 帧捕获 | 获取屏幕内容用于 AI 分析 |

**特殊操作**：

| 操作类型      | 说明     | 触发条件                             | 处理方式                  |
| ------------- | -------- | ------------------------------------ | ------------------------- |
| **Take_over** | 用户接管 | 遇到登录、验证码等需要人工干预的场景 | 暂停 AI，提示用户手动操作 |
| **Note**      | 记录内容 | 需要记录页面内容时                   | 保存页面信息到上下文      |
| **Call_API**  | 调用 API | 需要内容总结或外部服务时             | 调用外部 API 处理         |
| **Interact**  | 交互请求 | 需要用户选择或确认时                 | 暂停执行，等待用户输入    |
| **Finish**    | 任务完成 | 任务成功完成                         | 结束执行，返回结果消息    |

**操作执行流程**：

1. **坐标转换**：AI 模型输出相对坐标（0-1000），转换为绝对像素坐标
2. **操作执行**：通过 ADB 命令或 Scrcpy 控制 Socket 执行操作
3. **延迟等待**：每个操作后等待指定时间（默认 1 秒），确保界面响应
4. **操作反馈**：在投屏画面绘制操作可视化（高亮框、点击点、滑动轨迹）
5. **结果验证**：截图验证操作结果，决定下一步行动

**实现要点**：

- **多设备支持**：所有操作支持 `device_id` 参数，可指定设备执行
- **错误处理**：操作失败时返回 `ActionResult`，包含错误信息
- **敏感操作确认**：支付、删除等敏感操作需要用户确认
- **键盘管理**：输入文本前自动切换到 ADB Keyboard，输入后恢复原键盘
- **操作延迟**：根据操作类型和界面复杂度动态调整延迟时间

### 4.4 UI 界面设计

#### 4.4.1 布局：三栏式布局（深色模式）

**左侧栏：智能交互区 (AI Copilot)**

- 对话流：类似 ChatGPT 的聊天界面
- 思维链展示 (ToT)：实时显示 AI 思考过程
- 快捷指令板：常用任务卡片（一键清理、一键打卡）

**中间栏：手机镜像区 (Phone Mirror)**

- 实时画面：高清、高帧率手机屏幕映射
- AI 视觉层 (Overlay)：可操作元素上覆盖半透明彩色框
- 接管按钮：红色 "Stop/Pause" 按钮，立即停止 AI

**右侧栏：工作区与日志 (Workspace & Logs)**

- 设备状态：手机型号、电量、网络、ADB 连接状态
- 任务历史：操作日志，支持回放或导出
- 配置中心：模型选择、ADB 路径、截图压缩率等

#### 4.4.2 交互流程示例

1. 连接：USB 插入 → 自动识别设备 → 中间栏显示手机屏幕
2. 指令：左侧输入自然语言任务
3. 规划：左侧显示 AI 拆解的步骤
4. 执行：中间栏自动跳转，AI 识别并操作
5. 完成：左侧提示完成，右侧记录日志

---

## 五、开发指导原则

### 5.1 资源路径管理

**问题**：Electron 打包后文件结构会变

**解决方案**：

- Python 代码中不要写死路径
- 使用 `sys._MEIPASS` (PyInstaller 特有) 定位打包资源
- 示例：

```python
import sys
import os

if getattr(sys, 'frozen', False):
    # PyInstaller 打包后的路径
    base_path = sys._MEIPASS
else:
    # 开发环境路径
    base_path = os.path.dirname(__file__)

scrcpy_jar = os.path.join(base_path, 'scrcpy-server.jar')
adb_exe = os.path.join(base_path, 'adb.exe')
```

### 5.2 端口管理

**问题**：端口冲突（如 18080 被占用）

**解决方案**：

- Python 启动时绑定端口 0（随机分配）
- 将实际端口号打印到 stdout
- Electron 主进程监听 stdout，解析端口号
- 通过 preload.js 或 IPC 传递给渲染进程

### 5.3 ADB 版本隔离

**问题**：用户电脑可能已有 Android Studio 的 ADB

**解决方案**：

- 强制使用打包的 ADB 二进制
- 在 adbutils 初始化时指定 `adb_path` 为内置路径
- 完全隔离环境，避免版本冲突

### 5.3.1 USB 连接实现要点

**USB 设备检测**：

- **Windows 实现**：

  ```python
  # 使用 WMI 监听 USB 设备插拔
  import wmi
  c = wmi.WMI()
  watcher = c.Win32_VolumeChangeEvent.watch_for(
      EventType="__InstanceCreationEvent"
  )
  ```

- **macOS 实现**：

  ```python
  # 使用 IOKit 框架（需要 Objective-C 桥接或使用 pyobjc）
  # 或使用轮询方式：定期执行 adb devices
  ```

- **跨平台方案**：
  - 使用轮询方式：每 1-2 秒执行 `adb devices` 检测设备变化
  - 对比设备列表变化，判断设备插拔
  - 简单可靠，适合跨平台实现

**USB 授权处理**：

- **检测授权状态**：

  ```python
  import subprocess
  result = subprocess.run(['adb', 'devices'], capture_output=True, text=True)
  # 解析输出，检测 "unauthorized" 状态
  ```

- **授权超时处理**：

  - 检测到 "unauthorized" 时，启动 30 秒倒计时
  - 倒计时内状态变为 "device"，连接成功
  - 超时后提示用户："请在手机上点击'允许 USB 调试'"

- **授权提示优化**：
  - UI 显示清晰的授权指引（文字 + 图标）
  - 提供"我已授权"按钮，手动触发重新检测
  - 支持"记住此设备"选项（需要用户手动勾选）

**驱动检测与安装指引**：

- **Windows 驱动检测**：

  ```python
  # 检测设备管理器中的 Android 设备
  # 如果显示为"未知设备"或带黄色感叹号，说明驱动未安装
  ```

- **驱动安装指引**：
  - 提供 Google USB Driver 下载链接
  - 提供详细的安装步骤（图文教程）
  - 安装后自动检测并验证

**多设备管理实现**：

- **设备列表获取**：

  ```python
  # 使用 adbutils 库
  from adbutils import adb
  devices = adb.device_list()
  for device in devices:
      print(f"{device.serial} - {device.shell('getprop ro.product.model')}")
  ```

- **设备选择 UI**：
  - 显示设备列表（序列号、型号、连接方式）
  - 当前选中设备高亮显示
  - 支持快速切换设备

### 5.4 性能优化原则

**Python 端**：

- 不在 Python 里做图像解码（OpenCV），只做转发
- AI 识别另开线程处理，不阻塞视频流转发循环
- 使用 asyncio 保证并发处理能力

**Electron 端**：

- WebCodecs 实现复杂时，回退到 JMuxer（稳定性优先）
- 避免在主进程进行大量计算
- 渲染进程直接与 Python 服务通信，减少 IPC 开销

### 5.5 错误处理与用户体验

**USB 连接错误处理**：

- **设备未检测到**：

  - 提示："未检测到设备，请检查 USB 连接"
  - 提供"重新检测"按钮
  - 检查清单：USB 线是否连接、是否开启 USB 调试、驱动是否安装

- **设备未授权**：

  - 提示："请在手机上点击'允许 USB 调试'"
  - 显示倒计时（30 秒）
  - 提供"我已授权"按钮，手动触发检测

- **驱动未安装（Windows）**：

  - 检测到设备管理器中的异常设备
  - 提供驱动下载链接和安装教程
  - 安装后自动检测

- **设备离线（offline）**：
  - 提示："设备连接异常，正在尝试重新连接"
  - 自动执行：`adb kill-server` → `adb start-server` → 重新连接
  - 3 次失败后提示用户检查 USB 线和驱动

**Wi-Fi 连接错误处理**：

- **连接质量监控**：

  - UI 显示"无线连接质量"图标（信号格）
  - 质量差时提示："网络不稳定，建议使用 USB 连接"

- **一键修复**：
  - 提供"一键修复"按钮：`adb kill-server` → `adb start-server` → `connect`
  - 自动重连失败时，提供详细错误信息和解决建议

**通用错误处理**：

- **错误提示原则**：

  - 不要让用户查日志
  - 提供清晰的错误信息和解决建议
  - 自动重连失败时明确提示用户

- **连接方式建议**：
  - 关键任务（支付、抢票）自动建议使用 USB 有线连接
  - 日常使用可提示 Wi-Fi 连接的便利性
  - 支持一键切换连接方式

---

## 六、部署方案

### 6.1 打包策略

**Python 后端**：

- 使用 PyInstaller 单文件模式打包为 `.exe` (Windows) 或可执行文件 (macOS)
- 包含所有依赖：FastAPI、adbutils、asyncio 等
- 内置资源：`scrcpy-server.jar`、`adb` 二进制

**Electron 应用**：

- 使用 Electron-Vite 构建
- 将 Python 可执行文件打包进应用资源目录
- 主进程启动时检测并启动 Python 服务

### 6.2 文件结构

```
GAIA-WorkSpace-Phone/
├── electron/              # Electron 主应用
│   ├── main/             # 主进程
│   ├── renderer/         # 渲染进程 (Vue.js)
│   └── resources/        # 资源文件
│       ├── python-service.exe  # Python 打包后的可执行文件
│       ├── scrcpy-server.jar   # Scrcpy Server
│       └── adb.exe             # ADB 二进制
└── python-service/       # Python 后端服务
    ├── main.py           # FastAPI 入口
    ├── adb_manager.py    # ADB 连接管理
    ├── video_stream.py   # 视频流处理
    └── ai_core.py        # AI 核心模块
```

---

## 七、开发路线图建议

### Phase 1: 基础架构搭建

1. Electron + Vue.js 项目初始化
2. Python FastAPI 服务搭建
3. ADB 连接管理（USB 有线模式）
4. Scrcpy 视频流基础传输

### Phase 2: 核心功能实现

1. 前端视频解码（WebCodecs/JMuxer）
2. AI 视觉识别集成（云端模型）
3. 操作执行模块实现（参考 Open-AutoGLM）：
   - 基础触摸操作（Tap、Double Tap、Long Press、Swipe）
   - 文本输入操作（Type、Clear Text、键盘管理）
   - 系统按键操作（Back、Home、Launch App）
   - 辅助操作（Wait、Get Screenshot、Get Current App）
4. UI 三栏布局实现

### Phase 3: 稳定性优化

1. 无线 ADB 连接实现
2. 心跳保活与自动重连
3. 视频流动态优化
4. 错误处理与用户提示

### Phase 4: 高级功能

1. 自然语言任务规划
2. 工作流记忆与学习
3. 常用指令库
4. 任务历史与回放

---

## 八、关键技术要点总结

1. **架构**：Electron (UI) + Python (Service) 分离，Sidecar 模式
2. **通信**：WebSocket 传流，HTTP 传指令
3. **核心库**：adbutils (Python), FastAPI (Python), Electron-Vite (JS), WebCodecs (JS)
4. **操作能力**：参考 Open-AutoGLM 项目，支持丰富的操作类型（点击、双击、长按、滑动、输入、系统按键等）
5. **部署**：PyInstaller 打包 Python 为独立可执行文件，随 Electron 分发
6. **稳定性**：心跳保活、自动重连、动态比特率、私有 ADB 实例
7. **性能**：异步处理、线程隔离、直接通信、资源路径管理

---

## 九、参考资源

### 开源项目引用

- **Open-AutoGLM**: 本项目参考了 Open-AutoGLM 项目的操作实现（位于 `lib/Open-AutoGLM/`），该开源项目提供了完整的 Android 设备操作能力，包括基础触摸、文本输入、系统按键等操作类型。**注意**：Open-AutoGLM 为本项目的开源引用项目，不应对其进行修改。

### 核心技术库

- **Scrcpy**: https://github.com/Genymobile/scrcpy
- **adbutils**: https://github.com/openatx/adbutils
- **FastAPI**: https://fastapi.tiangolo.com/
- **Electron-Vite**: https://electron-vite.org/
- **WebCodecs API**: https://www.w3.org/TR/webcodecs/

---

**文档版本**: v1.0  
**最后更新**: 2024  
**维护者**: GAIA-WorkSpace-Phone 开发团队
